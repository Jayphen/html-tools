<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Markdown Preview</title>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      margin: 0;
      padding: 20px;
      background: #f5f5f5;
      min-height: 100vh;
    }

    .layout {
      display: flex;
      gap: 20px;
      margin-top: 20px;
    }

    .layout.has-sidebar .main-content {
      flex: 1;
      min-width: 0;
    }

    .sidebar {
      display: none;
      width: 220px;
      flex-shrink: 0;
      position: sticky;
      top: 20px;
      align-self: flex-start;
      max-height: calc(100vh - 40px);
      overflow-y: auto;
    }

    .layout.has-sidebar .sidebar {
      display: block;
    }

    .sidebar-title {
      font-size: 12px;
      font-weight: 600;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin: 0 0 12px 0;
    }

    .sidebar-list {
      list-style: none;
      margin: 0;
      padding: 0;
    }

    .sidebar-list li {
      margin-bottom: 4px;
    }

    .sidebar-link {
      display: block;
      padding: 8px 12px;
      border-radius: 6px;
      color: #333;
      text-decoration: none;
      font-size: 13px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      transition: background 0.15s;
    }

    .sidebar-link:hover {
      background: #e9ecef;
    }

    .sidebar-link.active {
      background: #2196F3;
      color: white;
    }

    h1 {
      margin: 0 0 20px 0;
      font-size: 24px;
      color: #333;
    }

    .drop-zone {
      border: 2px dashed #ccc;
      border-radius: 8px;
      padding: 40px;
      text-align: center;
      color: #666;
      background: #fafafa;
      transition: all 0.2s ease;
      cursor: pointer;
    }

    .drop-zone.dragover {
      border-color: #2196F3;
      background: #e3f2fd;
      color: #1976D2;
    }

    .drop-zone p {
      margin: 0;
      font-size: 16px;
    }

    .drop-zone small {
      display: block;
      margin-top: 8px;
      color: #999;
    }

    .previews {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .preview-card {
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      overflow: hidden;
    }

    .preview-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      background: #f8f9fa;
      border-bottom: 1px solid #e9ecef;
    }

    .preview-filename {
      font-weight: 600;
      color: #333;
      font-size: 14px;
    }

    .preview-actions {
      display: flex;
      gap: 8px;
    }

    .preview-actions button {
      padding: 4px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      transition: background 0.2s;
    }

    .btn-toggle {
      background: #e9ecef;
      color: #495057;
    }

    .btn-toggle:hover {
      background: #dee2e6;
    }

    .btn-toggle.active {
      background: #2196F3;
      color: white;
    }

    .btn-remove {
      background: #ffebee;
      color: #c62828;
    }

    .btn-remove:hover {
      background: #ffcdd2;
    }

    .preview-content {
      padding: 20px 24px;
      line-height: 1.6;
    }

    .preview-content.source {
      background: #f8f9fa;
      font-family: 'SF Mono', Monaco, 'Courier New', monospace;
      font-size: 13px;
      white-space: pre-wrap;
      color: #333;
    }

    /* Markdown rendered styles */
    .preview-content h1, .preview-content h2, .preview-content h3,
    .preview-content h4, .preview-content h5, .preview-content h6 {
      margin-top: 24px;
      margin-bottom: 16px;
      font-weight: 600;
      line-height: 1.25;
    }

    .preview-content h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
    .preview-content h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
    .preview-content h3 { font-size: 1.25em; }

    .preview-content p {
      margin-top: 0;
      margin-bottom: 16px;
    }

    .preview-content code {
      background: #f6f8fa;
      padding: 0.2em 0.4em;
      border-radius: 3px;
      font-family: 'SF Mono', Monaco, 'Courier New', monospace;
      font-size: 85%;
    }

    .preview-content pre {
      background: #2d2d2d;
      padding: 16px;
      border-radius: 6px;
      overflow-x: auto;
      margin: 0 0 16px 0;
    }

    .preview-content pre code {
      background: none;
      padding: 0;
      font-size: 13px;
      color: #ccc;
    }

    .preview-content blockquote {
      margin: 0 0 16px 0;
      padding: 0 1em;
      color: #6a737d;
      border-left: 4px solid #dfe2e5;
    }

    .preview-content ul, .preview-content ol {
      margin-top: 0;
      margin-bottom: 16px;
      padding-left: 2em;
    }

    .preview-content li + li {
      margin-top: 4px;
    }

    .preview-content table {
      border-collapse: collapse;
      width: 100%;
      margin-bottom: 16px;
    }

    .preview-content th, .preview-content td {
      border: 1px solid #dfe2e5;
      padding: 6px 13px;
    }

    .preview-content th {
      background: #f6f8fa;
      font-weight: 600;
    }

    .preview-content img {
      max-width: 100%;
      height: auto;
    }

    .preview-content a {
      color: #0366d6;
      text-decoration: none;
    }

    .preview-content a:hover {
      text-decoration: underline;
    }

    .preview-content hr {
      border: none;
      border-top: 1px solid #e1e4e8;
      margin: 24px 0;
    }

    .empty-state {
      text-align: center;
      color: #999;
      padding: 40px;
    }
  </style>
</head>
<body>
  <h1>Markdown Preview</h1>

  <div class="drop-zone" id="dropZone">
    <p>Drop .md files here</p>
    <small>or click to select files</small>
    <input type="file" id="fileInput" accept=".md,.markdown" multiple hidden>
  </div>

  <div class="layout" id="layout">
    <nav class="sidebar" id="sidebar">
      <h2 class="sidebar-title">Files</h2>
      <ul class="sidebar-list" id="sidebarList"></ul>
    </nav>
    <div class="main-content">
      <div class="previews" id="previews"></div>
    </div>
  </div>

  <script>
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');
    const previews = document.getElementById('previews');
    const layout = document.getElementById('layout');
    const sidebarList = document.getElementById('sidebarList');
    const files = new Map();

    // Preprocessor to detect unfenced code blocks
    // Pattern: a line with just a language name, followed by code-like content
    const KNOWN_LANGUAGES = [
      'sql', 'javascript', 'js', 'typescript', 'ts', 'python', 'py', 'ruby', 'rb',
      'java', 'c', 'cpp', 'c\\+\\+', 'csharp', 'c#', 'go', 'rust', 'php', 'swift',
      'kotlin', 'scala', 'html', 'css', 'scss', 'sass', 'less', 'json', 'yaml',
      'yml', 'xml', 'bash', 'shell', 'sh', 'zsh', 'powershell', 'ps1', 'dockerfile',
      'graphql', 'markdown', 'md', 'plaintext', 'text', 'txt'
    ];
    const langPattern = new RegExp(`^(${KNOWN_LANGUAGES.join('|')})\\s*$`, 'i');

    function preprocessMarkdown(content) {
      const lines = content.split('\n');
      const result = [];
      let i = 0;

      while (i < lines.length) {
        const line = lines[i];
        const langMatch = line.match(langPattern);

        // Check if this line is just a language name
        if (langMatch && i + 1 < lines.length) {
          const lang = langMatch[1].toLowerCase();
          const codeLines = [];
          let j = i + 1;

          // Skip one blank line if present
          if (lines[j] && lines[j].trim() === '') {
            j++;
          }

          // Collect code lines until we hit a markdown section marker or significant blank lines
          while (j < lines.length) {
            const codeLine = lines[j];

            // Stop at horizontal rules, headers, or multiple blank lines
            if (codeLine.match(/^#{1,6}\s/) || codeLine.match(/^---+\s*$/) || codeLine.match(/^\*\*\d+\\/)) {
              break;
            }

            // Stop at two consecutive blank lines
            if (codeLine.trim() === '' && j + 1 < lines.length && lines[j + 1].trim() === '') {
              break;
            }

            codeLines.push(codeLine);
            j++;
          }

          // Only treat as code if we found some content
          if (codeLines.length > 0 && codeLines.some(l => l.trim() !== '')) {
            // Remove trailing blank lines from code block
            while (codeLines.length > 0 && codeLines[codeLines.length - 1].trim() === '') {
              codeLines.pop();
            }

            result.push('```' + lang);
            result.push(...codeLines);
            result.push('```');
            i = j;
            continue;
          }
        }

        result.push(line);
        i++;
      }

      return result.join('\n');
    }

    const renderer = new marked.Renderer();
    renderer.code = function(codeOrToken, lang) {
      // Handle both old API (code, lang) and new API (token object)
      const code = typeof codeOrToken === 'object' ? codeOrToken.text : codeOrToken;
      const language = (typeof codeOrToken === 'object' ? codeOrToken.lang : lang) || 'plaintext';
      const escaped = code.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
      return `<pre><code class="language-${language}">${escaped}</code></pre>`;
    };

    marked.setOptions({
      breaks: true,
      gfm: true,
      renderer: renderer
    });

    dropZone.addEventListener('click', () => fileInput.click());

    dropZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropZone.classList.add('dragover');
    });

    dropZone.addEventListener('dragleave', () => {
      dropZone.classList.remove('dragover');
    });

    dropZone.addEventListener('drop', (e) => {
      e.preventDefault();
      dropZone.classList.remove('dragover');
      handleFiles(e.dataTransfer.files);
    });

    fileInput.addEventListener('change', (e) => {
      handleFiles(e.target.files);
      fileInput.value = '';
    });

    function handleFiles(fileList) {
      for (const file of fileList) {
        if (file.name.endsWith('.md') || file.name.endsWith('.markdown')) {
          const reader = new FileReader();
          reader.onload = (e) => {
            const id = `file-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            files.set(id, {
              name: file.name,
              content: e.target.result,
              showSource: false
            });
            renderPreviews();
          };
          reader.readAsText(file);
        }
      }
    }

    function renderPreviews() {
      previews.innerHTML = '';
      sidebarList.innerHTML = '';

      // Toggle sidebar visibility based on file count
      if (files.size > 1) {
        layout.classList.add('has-sidebar');
      } else {
        layout.classList.remove('has-sidebar');
      }

      if (files.size === 0) {
        return;
      }

      const fileIds = [];

      for (const [id, file] of files) {
        fileIds.push(id);

        // Create sidebar link
        const li = document.createElement('li');
        const link = document.createElement('a');
        link.className = 'sidebar-link';
        link.href = `#${id}`;
        link.textContent = file.name;
        link.onclick = (e) => {
          e.preventDefault();
          document.getElementById(id)?.scrollIntoView({ behavior: 'smooth', block: 'start' });
        };
        li.appendChild(link);
        sidebarList.appendChild(li);

        // Create preview card
        const card = document.createElement('div');
        card.className = 'preview-card';
        card.id = id;

        const header = document.createElement('div');
        header.className = 'preview-header';

        const filename = document.createElement('span');
        filename.className = 'preview-filename';
        filename.textContent = file.name;

        const actions = document.createElement('div');
        actions.className = 'preview-actions';

        const toggleBtn = document.createElement('button');
        toggleBtn.className = `btn-toggle ${file.showSource ? 'active' : ''}`;
        toggleBtn.textContent = file.showSource ? 'Source' : 'Preview';
        toggleBtn.onclick = () => {
          file.showSource = !file.showSource;
          renderPreviews();
        };

        const removeBtn = document.createElement('button');
        removeBtn.className = 'btn-remove';
        removeBtn.textContent = 'Remove';
        removeBtn.onclick = () => {
          files.delete(id);
          renderPreviews();
        };

        actions.appendChild(toggleBtn);
        actions.appendChild(removeBtn);
        header.appendChild(filename);
        header.appendChild(actions);

        const content = document.createElement('div');
        content.className = `preview-content ${file.showSource ? 'source' : ''}`;

        if (file.showSource) {
          content.textContent = file.content;
        } else {
          content.innerHTML = marked.parse(preprocessMarkdown(file.content));
        }

        card.appendChild(header);
        card.appendChild(content);
        previews.appendChild(card);
      }

      // Highlight code blocks after rendering
      Prism.highlightAll();

      // Set up intersection observer for active sidebar state
      if (files.size > 1) {
        setupScrollObserver(fileIds);
      }
    }

    let scrollObserver = null;

    function setupScrollObserver(fileIds) {
      if (scrollObserver) {
        scrollObserver.disconnect();
      }

      scrollObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          const link = sidebarList.querySelector(`a[href="#${entry.target.id}"]`);
          if (entry.isIntersecting) {
            // Remove active from all links
            sidebarList.querySelectorAll('.sidebar-link').forEach(l => l.classList.remove('active'));
            // Add active to current link
            link?.classList.add('active');
          }
        });
      }, {
        rootMargin: '-20% 0px -70% 0px',
        threshold: 0
      });

      fileIds.forEach(id => {
        const el = document.getElementById(id);
        if (el) scrollObserver.observe(el);
      });
    }
  </script>
</body>
</html>
